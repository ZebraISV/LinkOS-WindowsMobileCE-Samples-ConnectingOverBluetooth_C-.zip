/********************************************** 
 * CONFIDENTIAL AND PROPRIETARY 
 *
 * The source code and other information contained herein is the confidential and the exclusive property of
 * ZIH Corp. and is subject to the terms and conditions in your end user license agreement.
 * This source code, and any other information contained herein, shall not be copied, reproduced, published, 
 * displayed or distributed, in whole or in part, in any medium, by any means, for any purpose except as
 * expressly permitted under such license agreement.
 * 
 * Copyright ZIH Corp. 2011
 *
 * ALL RIGHTS RESERVED 
 ***********************************************/


#include "stdafx.h"
#include "BthUtils.h"
#include "resourceppc.h"

#include <windows.h>
#include <commctrl.h>


#define MAX_LOADSTRING 100

// Global Variables:
HINSTANCE			g_hInst;			// current instance
HWND					g_hDlg;

int g_iChatMode;
int g_iSelectedDeviceIndex;

BthUtils objBthUtils;
DeviceInfo *g_pLocalDeviceInfo, *g_pPeerDeviceInfo;
// Forward declarations of functions included in this code module:
INT_PTR CALLBACK	MainDlgProc(HWND, UINT, WPARAM, LPARAM);
DWORD WINAPI ShowDevices(LPVOID voidDlg);
void DisplayMessage(WCHAR *szMessage);
void SendZplData(HWND hDlg);
void SendCpclData(HWND hDlg);
void Cleanup();
//SDP record generated by bthnscreate.exe
BYTE rgbSdpRecord[] = {
         0x35, 0x4d, 0x09, 0x00, 0x01, 0x35, 0x11, 0x1c,
         0x29, 0xf9, 0xc0, 0xfd, 0xbb, 0x6e, 0x47, 0x97,
         0x9f, 0xa9, 0x3e, 0xc9, 0xa8, 0x54, 0x29, 0x0c,
         0x09, 0x00, 0x04, 0x35, 0x0c, 0x35, 0x03, 0x19,
         0x01, 0x00, 0x35, 0x05, 0x19, 0x00, 0x03, 0x08,
         0x1a, 0x09, 0x00, 0x06, 0x35, 0x09, 0x09, 0x65,
         0x6e, 0x09, 0x00, 0x6a, 0x09, 0x01, 0x00, 0x09,
         0x00, 0x09, 0x35, 0x08, 0x35, 0x06, 0x19, 0x11,
         0x05, 0x09, 0x01, 0x00, 0x09, 0x01, 0x00, 0x25,
         0x06, 0x53, 0x65, 0x72, 0x69, 0x61, 0x6c
};

//server GUID
WCHAR strGUID[]=L"29F9C0FD-BB6E-4797-9FA9-3EC9A854290C";

//SDP record size constant returned by bthnscreate.exe
#define SDP_RECORD_SIZE 0x0000004f
#define SDP_CHANNEL_OFFSET 40



int WINAPI WinMain(HINSTANCE hInstance,
                   HINSTANCE hPrevInstance,
                   LPTSTR    lpCmdLine,
                   int       nCmdShow)
{
	//Store the global instance. We'll need it for menu creation
	g_hInst=hInstance;
	DialogBox(hInstance, (LPCTSTR)IDD_MAIN, NULL, MainDlgProc);
	Cleanup();
	return 0;
}

// Message handler for the main dialog box.
INT_PTR CALLBACK MainDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	WCHAR szMessage[MAX_MESSAGE_SIZE];
	g_hDlg=hDlg;
	int iRetVal=0;
	switch (message)
    {
        case WM_INITDIALOG:
            {
				
				SetWindowText(GetDlgItem(hDlg, IDC_LABEL), L"Scanning...");	
				EnableWindow(GetDlgItem(hDlg, IDC_SEND), FALSE);
				EnableWindow(GetDlgItem(hDlg, IDC_SEND2), FALSE);

				SHINITDLGINFO shidi;
                shidi.dwMask = SHIDIM_FLAGS;
                shidi.dwFlags = SHIDIF_SIZEDLGFULLSCREEN;
                shidi.hDlg = hDlg;
                SHInitDialog(&shidi);


				SendMessage(GetDlgItem(hDlg, IDC_MESSAGES), LB_SETHORIZONTALEXTENT, 500, 0);

				//perform device inquiry on a new thread

				CreateThread(NULL, 0, ShowDevices, (LPVOID)hDlg, 0, NULL);

				//get local device info
				g_pLocalDeviceInfo = (DeviceInfo*)malloc(sizeof(DeviceInfo));
				objBthUtils.GetLocalDeviceName(g_pLocalDeviceInfo);
				
				iRetVal=objBthUtils.OpenServerConnection(rgbSdpRecord, SDP_RECORD_SIZE, SDP_CHANNEL_OFFSET, DisplayMessage);
				if(iRetVal!=0)
				{
					StringCchPrintf(szMessage, ARRAYSIZE(szMessage), L"%d: Server socket failed.", iRetVal); 
					SendMessage(GetDlgItem(hDlg, IDC_MESSAGES), LB_ADDSTRING,0,(LPARAM)szMessage);					
				}

            }
            return (INT_PTR)TRUE;

        case WM_COMMAND:
            switch(LOWORD(wParam))
			{
				case IDC_SEND_MESSAGES:
					switch (HIWORD(wParam)) 
					{ 
						case EN_SETFOCUS: 
							SipShowIM(SIPF_ON);
							break;
					}
					break;
				case IDC_DEVICES:
					switch (HIWORD(wParam)) 
					{ 
						case CBN_SELCHANGE: 
							g_iSelectedDeviceIndex=SendMessage(GetDlgItem(hDlg, IDC_DEVICES), CB_GETCURSEL, 0, 0);
							break;
					}
					break;

				case IDC_SEND:
					g_iSelectedDeviceIndex=SendMessage(GetDlgItem(hDlg, IDC_DEVICES), CB_GETCURSEL, 0, 0);
					SendZplData(hDlg);
					SetDlgItemText(hDlg, IDC_SEND_MESSAGES, L"");
					SetFocus(GetDlgItem(hDlg, IDC_SEND_MESSAGES));
					break;

				case IDC_SEND2:
					g_iSelectedDeviceIndex=SendMessage(GetDlgItem(hDlg, IDC_DEVICES), CB_GETCURSEL, 0, 0);
					SendCpclData(hDlg);
					SetDlgItemText(hDlg, IDC_SEND_MESSAGES, L"");
					SetFocus(GetDlgItem(hDlg, IDC_SEND_MESSAGES));
					break;

				case IDOK:
					EndDialog(hDlg, LOWORD(wParam));
					return TRUE;
					break;
			}
			break;
        case WM_CLOSE:
            EndDialog(hDlg, message);
            return TRUE;
			break;
    }
    return (INT_PTR)FALSE;
}
DWORD WINAPI ShowDevices(LPVOID voidDlg)
{
    HWND hDlg = (HWND) voidDlg;
	int iNumDevices=0, iRetVal=0;
	DeviceInfo *pPeerDevicesInfo=NULL;
	WCHAR szMessage[20];
	iRetVal=objBthUtils.DiscoverDevices();
	iNumDevices = objBthUtils.GetNumDevices();
	if(iRetVal==0)
	{
		pPeerDevicesInfo = (DeviceInfo*) malloc(sizeof(DeviceInfo)*iNumDevices);
		objBthUtils.GetDeviceInfo(pPeerDevicesInfo);
		for(int iCount = 0; iCount < iNumDevices;iCount++)
		{
			SendMessage(GetDlgItem(hDlg, IDC_DEVICES), CB_ADDSTRING,0,(LPARAM) pPeerDevicesInfo[iCount].szDeviceNameAddr);
			SendMessage(GetDlgItem(hDlg, IDC_DEVICES), CB_SETITEMDATA, iCount, (LPARAM) iCount);
		}
		SendMessage(GetDlgItem(hDlg, IDC_DEVICES), CB_SETCURSEL, 0,0);
		SetFocus(GetDlgItem(hDlg, IDC_DEVICES)); 
		
		SendMessage(GetDlgItem(hDlg, IDC_MESSAGES), LB_ADDSTRING,0,(LPARAM)L"Scanning Completed. Ready to print.");

		SetWindowText(GetDlgItem(hDlg, IDC_LABEL), L"Select a printer:");
		SetWindowText(GetDlgItem(hDlg, IDC_LABEL2), L"Press the appropriate button to print:");	
		EnableWindow(GetDlgItem(hDlg, IDC_SEND), TRUE);
		EnableWindow(GetDlgItem(hDlg, IDC_SEND2), TRUE);
		free(pPeerDevicesInfo);
	}
	else
	{
		StringCchPrintf(szMessage, ARRAYSIZE(szMessage), L"%d: Scanning failed.", iRetVal); 
		SendMessage(GetDlgItem(hDlg, IDC_MESSAGES), LB_ADDSTRING,0,(LPARAM)szMessage);
		SetWindowText(GetDlgItem(hDlg, IDC_LABEL), L"Scanning failed.");
	}
	return 0;
}

void DisplayMessage(WCHAR *szMessage)
{
	PostMessage(GetDlgItem(g_hDlg, IDC_MESSAGES), LB_ADDSTRING,0,(LPARAM) szMessage);

}
void SendZplData(HWND hDlg)
{
	int iRetVal=0;
	int iCount=0;
	char szMessage[] = "^XA^FO100,20^A0N,25,25^FDThis is a ZPL test.^FS^XZ"; 
	WCHAR szDlgText[MAX_MESSAGE_SIZE], szPeerDeviceName[MAX_NAME_SIZE], szPeerDeviceAddr[MAX_ADDR_SIZE];
	WCHAR szResponse[256];
	g_pPeerDeviceInfo = (DeviceInfo*)malloc(sizeof(DeviceInfo));
	if(objBthUtils.GetDeviceInfo(g_pPeerDeviceInfo, g_iSelectedDeviceIndex)!=0)
	{
		SendMessage(GetDlgItem(hDlg, IDC_MESSAGES), LB_ADDSTRING,0,(LPARAM) "Error retrieving peer device name.");
	}
	else
	{
		swscanf(g_pPeerDeviceInfo->szDeviceNameAddr, L"%s:%s", szPeerDeviceName, szPeerDeviceAddr);
	}

	GetDlgItemText(hDlg, IDC_SEND_MESSAGES, szDlgText,MAX_MESSAGE_SIZE);
	   


		iRetVal=objBthUtils.SendMessageToServer(strGUID, szMessage, g_iSelectedDeviceIndex);
	if(iRetVal)
	{
		StringCchPrintf(szResponse, ARRAYSIZE(szResponse), L"Could not deliver to %s. Socket error: %d", szPeerDeviceName, iRetVal);
		SendMessage(GetDlgItem(hDlg, IDC_MESSAGES), LB_ADDSTRING,0,(LPARAM)szResponse);
	}
	else
	{
		SendMessage(GetDlgItem(hDlg, IDC_MESSAGES), LB_ADDSTRING,0,(LPARAM) L"ZPL label sent.");
	}

	iCount=SendMessage(GetDlgItem(hDlg, IDC_MESSAGES), LB_GETCOUNT, 0,0);
	iCount=--iCount;
	SendMessage(GetDlgItem(hDlg, IDC_MESSAGES), LB_SETTOPINDEX,iCount,(LPARAM) szMessage);

}

void SendCpclData(HWND hDlg)
{
	int iRetVal=0;
	int iCount=0;
	char szMessage[] = "! 0 200 200 210 1\r\nTEXT 4 0 60 40 This is a CPCL test.\r\nFORM\r\nPRINT\r\n";
	WCHAR szDlgText[MAX_MESSAGE_SIZE], szPeerDeviceName[MAX_NAME_SIZE], szPeerDeviceAddr[MAX_ADDR_SIZE];
	WCHAR szResponse[256];
	g_pPeerDeviceInfo = (DeviceInfo*)malloc(sizeof(DeviceInfo));
	if(objBthUtils.GetDeviceInfo(g_pPeerDeviceInfo, g_iSelectedDeviceIndex)!=0)
	{
		SendMessage(GetDlgItem(hDlg, IDC_MESSAGES), LB_ADDSTRING,0,(LPARAM) "Error retrieving peer device name.");
	}
	else
	{
		swscanf(g_pPeerDeviceInfo->szDeviceNameAddr, L"%s:%s", szPeerDeviceName, szPeerDeviceAddr);
	}

	GetDlgItemText(hDlg, IDC_SEND_MESSAGES, szDlgText,MAX_MESSAGE_SIZE);
	   


		iRetVal=objBthUtils.SendMessageToServer(strGUID, szMessage, g_iSelectedDeviceIndex);
	if(iRetVal)
	{
		StringCchPrintf(szResponse, ARRAYSIZE(szResponse), L"Could not deliver to %s. Socket error: %d", szPeerDeviceName, iRetVal);
		SendMessage(GetDlgItem(hDlg, IDC_MESSAGES), LB_ADDSTRING,0,(LPARAM)szResponse);
	}
	else
	{
		SendMessage(GetDlgItem(hDlg, IDC_MESSAGES), LB_ADDSTRING,0,(LPARAM) L"CPCL label sent.");
	}

	iCount=SendMessage(GetDlgItem(hDlg, IDC_MESSAGES), LB_GETCOUNT, 0,0);
	iCount=--iCount;
	SendMessage(GetDlgItem(hDlg, IDC_MESSAGES), LB_SETTOPINDEX,iCount,(LPARAM) szMessage);

}


void Cleanup()
{
	free(g_pLocalDeviceInfo);
	free(g_pPeerDeviceInfo);

}